<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Daily Crossword</title>

<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #fafafa;
        color: #222;
    }

    .header {
        background: #008080;
        color: white;
        padding: 20px 10px;
        text-align: center;
        font-size: 26px;
        font-weight: bold;
    }

    .subtitle {
        text-align: center;
        color: #555;
        font-style: italic;
        margin-top: 6px;
        margin-bottom: 15px;
        font-size: 15px;
    }

    .container {
        max-width: 900px;
        margin: auto;
        padding: 10px;
    }

    .grid-wrapper {
        display: flex;
        justify-content: center;
        overflow-x: auto;
    }

    table.crossword {
        border-collapse: collapse;
        margin-bottom: 20px;
        user-select: none;
    }

    table.crossword td {
        width: 32px;
        height: 32px;
        border: 1px solid #999;
        padding: 0;
        text-align: center;
        vertical-align: middle;
        position: relative;
        font-size: 20px;
        font-weight: bold;
        background: #ffffff;
    }

    @media (max-width: 600px) {
        table.crossword td {
            width: 26px;
            height: 26px;
            font-size: 17px;
        }
    }

    @media (max-width: 420px) {
        table.crossword td {
            width: 22px;
            height: 22px;
            font-size: 15px;
        }
    }

    /* Gold blocks (compatible with old class names) */
    td.block,
    td.gold,
    td.blk,
    td.cell-block {
        background: #d8c178 !important;
    }

    .num {
        position: absolute;
        top: 1px;
        left: 2px;
        font-size: 10px;
        color: #222;
        font-weight: bold;
    }

    td input {
        width: 100%;
        height: 100%;
        text-transform: uppercase;
        font-size: inherit;
        border: none;
        outline: none;
        text-align: center;
        background: transparent;
        font-weight: bold;
    }

    .clues {
        margin-top: 20px;
    }

    .clues h3 {
        margin-bottom: 5px;
        color: #008080;
    }

    .clue-list {
        font-size: 16px;
        line-height: 1.6;
    }

    .clue-item {
        padding: 2px 4px;
        border-radius: 3px;
        cursor: pointer;
    }

    .clue-item.active-clue {
        background: rgba(0, 128, 128, 0.12);
        font-weight: bold;
    }

    td.active-word {
        background: #ffe9a8;
    }

    td.block.active-word {
        background: #d8c178 !important;
    }

    td.active-cell {
        outline: 2px solid #008080;
        outline-offset: -1px;
    }

    .clear-wrapper {
        text-align: center;
        padding: 20px;
    }

    .clear-btn {
        background: #008080;
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 17px;
        font-weight: bold;
    }
</style>
</head>

<body>

<div class="header">DAILY CROSSWORD</div>
<div class="subtitle">
    Type letters into the boxes. Progress saves automatically. Tap a clue to highlight its word.
</div>

<div class="container">
    <div id="puzzleArea"></div>

    <div class="clues">
        <h3>Across</h3>
        <div id="across"></div>

        <h3 style="margin-top:20px;">Down</h3>
        <div id="down"></div>
    </div>

    <div class="clear-wrapper">
        <button class="clear-btn" onclick="clearGrid()">Clear My Answers</button>
    </div>
</div>

<script>
const LS_KEY = "crossword-progress";

let puzzleData = null;
let cellMap = [];
let acrossMap = {};
let downMap = {};
let activeDirection = null;      // "across" | "down"
let activeClueNum = null;
let activeCells = [];
let activeIndex = 0;

fetch("puzzle.json")
    .then(r => r.json())
    .then(data => {
        puzzleData = data;
        buildPuzzle(data);
    });

function buildPuzzle(puz) {
    cellMap = [];
    acrossMap = {};
    downMap = {};

    const wrap = document.createElement("div");
    wrap.className = "grid-wrapper";

    const tbl = document.createElement("table");
    tbl.className = "crossword";

    const saved = JSON.parse(localStorage.getItem(LS_KEY) || "{}");

    for (let r = 0; r < puz.rows; r++) {
        cellMap[r] = [];
        const tr = document.createElement("tr");

        for (let c = 0; c < puz.cols; c++) {
            const cell = document.createElement("td");
            const cellObj = { td: cell, input: null, acrossNum: null, downNum: null };
            cellMap[r][c] = cellObj;

            if (puz.grid[r][c] === "#") {
                cell.classList.add("block");
            } else {
                const inp = document.createElement("input");
                inp.maxLength = 1;
                inp.dataset.row = r;
                inp.dataset.col = c;
                inp.dataset.prev = "";

                const key = r + "-" + c;
                if (saved[key]) {
                    inp.value = saved[key];
                    inp.dataset.prev = saved[key];
                }

                inp.addEventListener("input", handleInput);
                inp.addEventListener("keydown", handleKeyNav); // optional arrows on desktop
                inp.addEventListener("focus", () => {
                    onCellFocus(r, c);
                });

                cell.appendChild(inp);
                cellObj.input = inp;
            }

            if (puz.numbers[r][c] > 0) {
                const n = document.createElement("div");
                n.className = "num";
                n.textContent = puz.numbers[r][c];
                cell.appendChild(n);
            }

            cell.addEventListener("click", () => {
                if (!cellMap[r][c].input) return;
                onCellFocus(r, c, true);
            });

            tr.appendChild(cell);
        }
        tbl.appendChild(tr);
    }

    wrap.appendChild(tbl);
    document.getElementById("puzzleArea").appendChild(wrap);

    computeWordMaps(puz);
    buildClues(puz);
}

/* Build across/down membership from grid + numbers */
function computeWordMaps(puz) {
    const rows = puz.rows;
    const cols = puz.cols;
    const grid = puz.grid;
    const nums = puz.numbers;

    // Across starts
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (grid[r][c] === "#") continue;

            const startsAcross =
                (c === 0 || grid[r][c - 1] === "#") &&
                (c + 1 < cols && grid[r][c + 1] !== "#");

            if (startsAcross && nums[r][c] > 0) {
                const clueNum = nums[r][c];
                let cc = c;
                while (cc < cols && grid[r][cc] !== "#") {
                    cellMap[r][cc].acrossNum = clueNum;
                    cc++;
                }
            }
        }
    }

    // Down starts
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (grid[r][c] === "#") continue;

            const startsDown =
                (r === 0 || grid[r - 1][c] === "#") &&
                (r + 1 < rows && grid[r + 1][c] !== "#");

            if (startsDown && nums[r][c] > 0) {
                const clueNum = nums[r][c];
                let rr = r;
                while (rr < rows && grid[rr][c] !== "#") {
                    cellMap[rr][c].downNum = clueNum;
                    rr++;
                }
            }
        }
    }

    acrossMap = {};
    downMap = {};

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cellObj = cellMap[r][c];
            const td = cellObj.td;
            const inp = cellObj.input;

            if (cellObj.acrossNum != null) {
                const n = cellObj.acrossNum;
                td.dataset.across = n;
                if (inp) inp.dataset.across = n;
                if (!acrossMap[n]) acrossMap[n] = [];
                acrossMap[n].push({ r, c, td, input: inp });
            }

            if (cellObj.downNum != null) {
                const n = cellObj.downNum;
                td.dataset.down = n;
                if (inp) inp.dataset.down = n;
                if (!downMap[n]) downMap[n] = [];
                downMap[n].push({ r, c, td, input: inp });
            }
        }
    }
}

/* Build clickable clues */
function buildClues(p) {
    const acrossContainer = document.getElementById("across");
    const downContainer = document.getElementById("down");
    acrossContainer.innerHTML = "";
    downContainer.innerHTML = "";

    const acrossNums = Object.keys(p.across).map(n => parseInt(n, 10)).sort((a,b)=>a-b);
    for (let n of acrossNums) {
        const div = document.createElement("div");
        div.className = "clue-list clue-item";
        div.dataset.clueType = "across";
        div.dataset.clueNumber = n;
        div.innerHTML = `<b>${n}</b>. ${p.across[n]}`;
        div.addEventListener("click", () => {
            activateWord("across", n, true);
        });
        acrossContainer.appendChild(div);
    }

    const downNums = Object.keys(p.down).map(n => parseInt(n, 10)).sort((a,b)=>a-b);
    for (let n of downNums) {
        const div = document.createElement("div");
        div.className = "clue-list clue-item";
        div.dataset.clueType = "down";
        div.dataset.clueNumber = n;
        div.innerHTML = `<b>${n}</b>. ${p.down[n]}`;
        div.addEventListener("click", () => {
            activateWord("down", n, true);
        });
        downContainer.appendChild(div);
    }
}

/* Core: activate a word (direction + clue number) and lock direction */
function activateWord(direction, clueNum, focusFirst) {
    clearHighlights();

    activeDirection = direction;
    activeClueNum = clueNum;
    activeCells = [];
    activeIndex = 0;

    const map = direction === "across" ? acrossMap : downMap;
    const cells = map[clueNum] || [];
    activeCells = cells.slice();

    activeCells.forEach(cell => {
        cell.td.classList.add("active-word");
    });

    document.querySelectorAll(".clue-item").forEach(el => {
        el.classList.remove("active-clue");
    });

    const clueSel = `.clue-item[data-clue-type="${direction}"][data-clue-number="${clueNum}"]`;
    const clueEl = document.querySelector(clueSel);
    if (clueEl) clueEl.classList.add("active-clue");

    if (focusFirst && activeCells.length > 0) {
        let idx = 0;
        for (let i = 0; i < activeCells.length; i++) {
            const cell = activeCells[i];
            if (cell.input && cell.input.value === "") {
                idx = i;
                break;
            }
        }
        activeIndex = idx;
        focusActiveCell();
    }
}

function clearHighlights() {
    document.querySelectorAll("td").forEach(td => {
        td.classList.remove("active-word");
        td.classList.remove("active-cell");
    });
    document.querySelectorAll(".clue-item").forEach(el => {
        el.classList.remove("active-clue");
    });
}

/* When a cell gets focus or is clicked */
function onCellFocus(r, c, byClick = false) {
    const cellObj = cellMap[r][c];
    if (!cellObj || !cellObj.input) return;

    // If we already have an active word, and this cell belongs to that same word, stay in that word
    if (activeDirection && activeClueNum != null) {
        if (
            (activeDirection === "across" && cellObj.acrossNum === activeClueNum) ||
            (activeDirection === "down" && cellObj.downNum === activeClueNum)
        ) {
            // Just move the activeIndex to this cell
            const cells = activeCells;
            for (let i = 0; i < cells.length; i++) {
                if (cells[i].r === r && cells[i].c === c) {
                    activeIndex = i;
                    focusActiveCell();
                    return;
                }
            }
        }
    }

    // Otherwise, pick a direction for this cell
    let dir = null;
    let num = null;

    // Prefer current direction if this cell supports it
    if (activeDirection === "across" && cellObj.acrossNum != null) {
        dir = "across";
        num = cellObj.acrossNum;
    } else if (activeDirection === "down" && cellObj.downNum != null) {
        dir = "down";
        num = cellObj.downNum;
    } else if (cellObj.acrossNum != null) {
        dir = "across";
        num = cellObj.acrossNum;
    } else if (cellObj.downNum != null) {
        dir = "down";
        num = cellObj.downNum;
    }

    if (!dir || !num) return;

    activateWord(dir, num, false);

    // Move index to this cell inside the chosen word
    for (let i = 0; i < activeCells.length; i++) {
        if (activeCells[i].r === r && activeCells[i].c === c) {
            activeIndex = i;
            break;
        }
    }
    focusActiveCell();
}

function focusActiveCell() {
    document.querySelectorAll("td").forEach(td => td.classList.remove("active-cell"));
    if (!activeCells.length) return;
    const cell = activeCells[activeIndex];
    if (!cell || !cell.input) return;
    cell.td.classList.add("active-cell");
    cell.input.focus();
    cell.input.select();
}

/* Move to next empty cell in this word (skip already-filled) */
function moveToNextEmptyCell() {
    if (!activeCells.length) return;
    for (let i = activeIndex + 1; i < activeCells.length; i++) {
        const cell = activeCells[i];
        if (cell.input && cell.input.value === "") {
            activeIndex = i;
            focusActiveCell();
            return;
        }
    }
    // No later empty; stay on current cell
    focusActiveCell();
}

/* Move to previous cell (we don't skip filled when going backwards) */
function moveToPrevCell() {
    if (!activeCells.length) return;
    if (activeIndex > 0) {
        activeIndex--;
    }
    focusActiveCell();
}

/* Main input handler (works on phones + tablets + desktop) */
function handleInput(e) {
    const input = e.target;
    const r = parseInt(input.dataset.row, 10);
    const c = parseInt(input.dataset.col, 10);

    let prev = input.dataset.prev || "";
    let val = input.value.toUpperCase();

    // Ensure we're in the correct active word for this cell
    if (!activeCells.some(cell => cell.r === r && cell.c === c)) {
        onCellFocus(r, c, false);
    }

    if (val.length > 1) {
        val = val.slice(-1);
    }

    if (/^[A-Z]$/.test(val)) {
        input.value = val;
        input.dataset.prev = val;
        saveProgress();
        moveToNextEmptyCell();
    } else if (val === "" && prev !== "") {
        // Treat as backspace
        input.dataset.prev = "";
        saveProgress();
        moveToPrevCell();
    } else {
        // Non-letter or weird input
        input.value = "";
        input.dataset.prev = "";
        saveProgress();
    }
}

/* Optional: arrow key navigation for physical keyboards */
function handleKeyNav(e) {
    const key = e.key;
    if (!activeCells.length) return;

    if (key === "ArrowRight") {
        e.preventDefault();
        activeDirection = "across";
        if (activeIndex < activeCells.length - 1) {
            activeIndex++;
        }
        focusActiveCell();
    } else if (key === "ArrowLeft") {
        e.preventDefault();
        activeDirection = "across";
        if (activeIndex > 0) {
            activeIndex--;
        }
        focusActiveCell();
    } else if (key === "ArrowDown") {
        e.preventDefault();
        activeDirection = "down";
        if (activeIndex < activeCells.length - 1) {
            activeIndex++;
        }
        focusActiveCell();
    } else if (key === "ArrowUp") {
        e.preventDefault();
        activeDirection = "down";
        if (activeIndex > 0) {
            activeIndex--;
        }
        focusActiveCell();
    }
}

/* Auto-save */
function saveProgress() {
    const inputs = document.querySelectorAll("td input");
    let out = {};

    inputs.forEach(inp => {
        let td = inp.parentElement;
        let tr = td.parentElement;
        let r = tr.rowIndex;
        let c = td.cellIndex;
        if (inp.value.trim() !== "") {
            out[r + "-" + c] = inp.value.toUpperCase();
        }
    });

    localStorage.setItem(LS_KEY, JSON.stringify(out));
}

/* Clear button */
function clearGrid() {
    localStorage.removeItem(LS_KEY);
    document.querySelectorAll("td input").forEach(i => {
        i.value = "";
        i.dataset.prev = "";
    });
    clearHighlights();
}
</script>

</body>
</html>
